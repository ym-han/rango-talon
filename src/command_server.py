import json
import time
from typing import Any, Union

from talon import Module, actions, clip

from .versions import COMMAND_VERSION

mod = Module()

MINIMUM_SLEEP_TIME_SECONDS = 0.0005


def send_request_and_wait(command: dict) -> Any:
    """Sends a command to the browser extension and waits for a response"""
    json_message = json.dumps(command)
    with clip.revert():
        _set_transient_clipboard_text(json_message)
        actions.user.rango_type_hotkey()
        response = _read_json_response_with_timeout(3.0)

    return response


def _read_json_response_with_timeout(timeout_seconds) -> Any:
    """Repeatedly tries to read a json object from the clipboard, waiting
    until the message type is "response"

    Raises:
        Exception: If we timeout waiting for a response

    Returns:
        Any: The json-decoded contents of the file
    """
    timeout_time = time.perf_counter() + timeout_seconds
    sleep_time = MINIMUM_SLEEP_TIME_SECONDS
    message = None
    initial_raw_text = clip.text()
    while True:
        raw_text = clip.text()
        if raw_text is None:
            # Skip this iteration if clipboard is empty/None
            actions.sleep(sleep_time)
            continue

        try:
            message = json.loads(raw_text)
            if message["type"] == "response":
                return message
        # We make sure the message is valid JSON. For example, if a click command
        # results in something being copied to the clipboard and we check the clipboard
        # before Rango has time to copy the response to the clipboard.
        except ValueError as error:
            if initial_raw_text == raw_text:
                # Sanity check to make sure the initial request was valid JSON
                raise ValueError("The request message wasn't valid JSON")

        actions.sleep(sleep_time)

        time_left = timeout_time - time.perf_counter()

        if time_left < 0:
            _send_request_timed_out()
            raise TimeoutError("Timed out waiting for response")

        # NB: We use minimum sleep time here to ensure that we don't spin with
        # small sleeps due to clock slip
        sleep_time = max(min(sleep_time * 2, time_left), MINIMUM_SLEEP_TIME_SECONDS)


# This doesn't wait for the extension to respond to avoid creating an infinite
# loop if the extension is not responsive
def _send_request_timed_out():
    """Sends a request timed out message to the browser extension"""
    message = {
        "version": COMMAND_VERSION,
        "type": "request",
        "action": {"name": "requestTimedOut"},
    }
    json_message = json.dumps(message)
    _set_transient_clipboard_text(json_message)
    actions.user.rango_type_hotkey()
    actions.sleep("200ms")


def _set_transient_clipboard_text(text: str):
    """Sets the clipboard to the given text, making it transient"""
    # The try except is only necessary because mime type assignment is only
    # supported in beta. To be removed once it's in public.
    try:
        mime = clip.MimeData()
        mime.text = text
        mime["ExcludeClipboardContentFromMonitorProcessing"] = b"true"
        mime["org.nspasteboard.AutoGeneratedType"] = b"true"
        mime["org.nspasteboard.TransientType"] = b"true"
        clip.set_mime(mime)
    except TypeError:
        clip.set_text(text)
